# -*- coding: utf-8 -*-
"""Корреляционный анализ.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xEHK69B6JQ-54GxwhReaHxCk3cYX5Ph6

# Домашнее задание к лекции «Корреляция и корреляционный анализ»

Возьмите датасет Mortality and Water Hardness**
www.kaggle.com...r-hardness

В этом датасете содержатся данные по средней годовой смертности на
100000 населения и концентрации кальция в питьевой воде для 61
большого города в Англии и Уэльсе. Города дополнительно поделены на
северные и южные.

## Задание 1.
## Ответить на вопрос: есть ли связь между жёсткостью воды и средней годовой смертностью?

* Построить точечный график
* Рассчитать коэффициенты корреляции Пирсона и Спирмена
* Построить модель линейной регрессии
* Рассчитать коэффициент детерминации
* Вывести график остатков
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
import statsmodels.api as sm
from statsmodels.sandbox.regression.predstd import wls_prediction_std

water_data = pd.read_csv('water.csv')
water_data.head()

# строим точечный график
water_data.plot(kind='scatter', x='hardness', y='mortality')

# рассчитываем коэффициент корреляции Пирсона
water_data[['hardness', 'mortality']].corr()

# рассчитываем коэффициент корреляции Спирмена
water_data[['hardness', 'mortality']].corr(method='spearman')

# строим модель линейной регрессии
X = water_data[['hardness']]
y = water_data['mortality']

X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42)

X_train.shape

X_test.shape

y_train.shape

model = LinearRegression()
model.fit(X_train, y_train)

model.coef_

model.intercept_

y_pred = model.predict(X_test)
y_pred

y_test

# рассчитываем значение коэффициента детерминации
model.score(X_test, y_test)

"""Значение коэффициента детерминации ближе к 0, чем к 1, что означает низкую значимость модели (входная переменная "hardness" плохо объясняет поведение выходной "mortality", что может говорить об отсутствии между ними связи)."""

plt.scatter(X_test, y_test)
plt.plot(X_test, y_pred, c='r')

# альтернативный способ из statsmodel
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.30, random_state=42)

X_const = sm.add_constant(X_train)

X_const

model = sm.OLS(y_train, X_const)
results = model.fit()
print(results.summary())

print('Parameters: ', results.params)
print('R2: ', results.rsquared)

prstd, iv_l, iv_u = wls_prediction_std(results)
# для каждой точки получаем не просто сам прогноз, но и доверительный интервал
# с увеличением количества факторов, этот интервал будет уменьшаться
fig, ax = plt.subplots(figsize=(8,6))

ax.plot(X_const.iloc[:, 1], y_train, 'o', label="data")
ax.plot(X_const.iloc[:, 1], results.fittedvalues, 'r--.', label="OLS")
ax.plot(X_const.iloc[:, 1], iv_u, 'g--')
ax.plot(X_const.iloc[:, 1], iv_l, 'g--')
ax.legend(loc='best')

# посмотрим на остатки
plt.scatter(x=X_const.iloc[:, 1], y=results.resid)
plt.xlabel('Прогноз')
plt.ylabel('Остатки')

plt.hist(results.resid, bins=20)

"""По графику остатков видим, что наблюдается некая систематическая составляющая, также есть резкие выбросы и закономерность в чередовании знаков, что говорит о том, что модель подобрана неправильно.

## Задание 2.
## Ответить на вопрос: сохраняется ли аналогичная зависимость для северных и южных городов по отдельности?

* Разделить данные на 2 группы
* Повторить аналогичные шаги из пункта 1 для каждой группы по отдельности
"""

water_data.groupby(['location']).plot(kind='scatter', x='hardness', y='mortality')

water_data.groupby(['location'])[['hardness', 'mortality']].corr()

water_data.groupby(['location'])[['hardness', 'mortality']].corr(method='spearman')

"""Видим, что коэффициент корреляции (в независимости от выбранного метода) довольно низок в северных регионах, в то время как в южных регионах коэффициент близок к среднему значению, что предварительно может говорить о наличии связи."""

# разделим данные на две группы
north_water_data = water_data[water_data.location == 'North']
south_water_data = water_data[water_data.location == 'South']

north_water_data.head()

# строим модель линейной регрессии для северных регионов
X = north_water_data[['hardness']]
y = north_water_data['mortality']

X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42)

X_train.shape

X_test.shape

y_train.shape

model = LinearRegression()
model.fit(X_train, y_train)

model.coef_

model.intercept_

y_pred = model.predict(X_test)
y_pred

y_test

# получаем значение коэффициента детерминации
model.score(X_test, y_test)

"""Значение коэффициента детерминации ниже нуля, что означает низкую значимость модели при рассмотрении северных городов (входная переменная "hardness" плохо объясняет поведение выходной "mortality", что может говорить об отсутствии между ними связи).
Если коэффициент детерминации меньше нуля, это значит, что разработанная модель даёт прогноз даже хуже, чем простое усреднение.
"""

plt.scatter(X_test, y_test)
plt.plot(X_test, y_pred, c='r')

# альтернативный способ из statsmodel
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.30, random_state=42)

X_const = sm.add_constant(X_train)

X_const

model = sm.OLS(y_train, X_const)
results = model.fit()
print(results.summary())

print('Parameters: ', results.params)
print('R2: ', results.rsquared)

prstd, iv_l, iv_u = wls_prediction_std(results)
# для каждой точки получаем не просто сам прогноз, но и доверительный интервал
# с увеличением количества факторов, этот интервал будет уменьшаться
fig, ax = plt.subplots(figsize=(8,6))

ax.plot(X_const.iloc[:, 1], y_train, 'o', label="data")
ax.plot(X_const.iloc[:, 1], results.fittedvalues, 'r--.', label="OLS")
ax.plot(X_const.iloc[:, 1], iv_u, 'g--')
ax.plot(X_const.iloc[:, 1], iv_l, 'g--')
ax.legend(loc='best')

# посмотрим на остатки
plt.scatter(x=X_const.iloc[:, 1], y=results.resid)
plt.xlabel('Прогноз')
plt.ylabel('Остатки')

plt.hist(results.resid, bins=20)

"""Опять же, как и при рассмотрении данных признаков без разделения на группы по регионам, видим, что наблюдается некая систематическая составляющая, также есть резкие выбросы и закономерность в чередовании знаков, что говорит о том, что модель подобрана неправильно."""

# строим модель линейной регрессии для южных регионов
X = south_water_data[['hardness']]
y = south_water_data['mortality']

X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42)

X_train.shape

X_test.shape

y_train.shape

model = LinearRegression()
model.fit(X_train, y_train)

model.coef_

model.intercept_

y_pred = model.predict(X_test)
y_pred

y_test

# получаем значение коэффициента детерминации
model.score(X_test, y_test)

"""Значение коэффициента детерминации ниже нуля, что означает низкую значимость модели при рассмотрении северных городов (входная переменная "hardness" плохо объясняет поведение выходной "mortality", что может говорить об отсутствии между ними связи).
Если коэффициент детерминации меньше нуля, это значит, что разработанная модель даёт прогноз даже хуже, чем простое усреднение.
"""

plt.scatter(X_test, y_test)
plt.plot(X_test, y_pred, c='r')

# альтернативный способ из statsmodel
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.30, random_state=42)

X_const = sm.add_constant(X_train)

X_const

model = sm.OLS(y_train, X_const)
results = model.fit()
print(results.summary())

print('Parameters: ', results.params)
print('R2: ', results.rsquared)

prstd, iv_l, iv_u = wls_prediction_std(results)
# для каждой точки получаем не просто сам прогноз, но и доверительный интервал
# с увеличением количества факторов, этот интервал будет уменьшаться
fig, ax = plt.subplots(figsize=(8,6))

ax.plot(X_const.iloc[:, 1], y_train, 'o', label="data")
ax.plot(X_const.iloc[:, 1], results.fittedvalues, 'r--.', label="OLS")
ax.plot(X_const.iloc[:, 1], iv_u, 'g--')
ax.plot(X_const.iloc[:, 1], iv_l, 'g--')
ax.legend(loc='best')

# посмотрим на остатки
plt.scatter(x=X_const.iloc[:, 1], y=results.resid)
plt.xlabel('Прогноз')
plt.ylabel('Остатки')

plt.hist(results.resid, bins=20)

"""Опять же, как и при рассмотрении данных признаков без разделения на группы по регионам, видим, что наблюдается некая систематическая составляющая, также есть резкие выбросы и закономерность в чередовании знаков, что говорит о том, что модель подобрана неправильно.

Таким образом, если при рассмотрении признаков без группировки по регионам наблюдалась минимальная связь между данными признаками.
Для северных и южных городов по отдельности аналогичная зависимость не сохраняется.
"""