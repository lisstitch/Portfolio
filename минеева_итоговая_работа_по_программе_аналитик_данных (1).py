# -*- coding: utf-8 -*-
"""Минеева_Итоговая работа по программе Аналитик данных.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1D5EfiGWvMFtxfg-SQDsRSCRpRS4re9HU

# **Анализ сотрудников компании и факторов увольнений (поиск инсайтов, составление рекомендаций стейкхолдерам, построение предиктивной модели оттока сотрудников)**

# **1. Подготовка к исследованию**

## 1.1 Импортируем необходимые библиотеки
"""

import pandas as pd
import numpy as np
from numpy import where
import matplotlib.pyplot as plt
import matplotlib
from matplotlib import pyplot
import seaborn as sns
import plotly.express as px
import plotly.graph_objects as go
from wordcloud import WordCloud
from plotly.offline import iplot
from plotly.subplots import make_subplots
import missingno as msno
from pandas.plotting import parallel_coordinates
import altair as alt
import sklearn
from sklearn.preprocessing import LabelEncoder
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import classification_report, accuracy_score
from sklearn.datasets import make_classification
import collections
from collections import Counter
import imblearn
from imblearn.over_sampling import SMOTE

"""## 1.2 Импортируем данные"""

df = pd.read_csv('HR.csv', sep = ',', header = 0)

df.head()

"""# **2. Исследование данных**

## 2.1 Кратко описываем данные
"""

num_rows, num_cols = df.shape
print(f'Number of rows: {num_rows}')
print(f'Number of columns: {num_cols}')

"""Каждая строка представляет собой информацию о сотруднике касательно таких аспектов, как расходы, личные, рабочие и финансовые факторы.

## 2.2 Получаем сводную информацию о данных
"""

df.info()

"""1. Age - Возраст сотрудника
2. Attrition - Увольнение сотрудника
3. BusinessTravel - Частота командировок
4. DailyRate - Ежедневная ставка
5. Department - Отдел, сфера деятельности
6. DistanceFromHome - Расстояние от дома до работы
7. Education - Образование
8. EducationField - Сфера образования, специальность
9. EmployeeCount - Количество сотрудников (одно уникальное значение - 1)
10. EmployeeNumber - ID сотрудника
11. EnvironmentSatisfaction - Удовлетворение окружающей средой на работе
12. Gender - Пол сотрудника
13. HourlyRate - Часовая ставка сотрудника
14. JobInvolvement - Вовлеченность сотрудника в работу
15. JobLevel - Должностная позиция сотрудника (начинающий специалист, специалист среднего уровня, старший специалист, руководитель, управляющий)
16. JobRole - Конкретная должность сотрудника
17. JobSatisfaction - Удовлетворенность работой
18. MaritalStatus - Семейное положение
19. MonthlyIncome - Месячный доход
20. MonthlyRate - Месячная ставка
21. NumCompaniesWorked - Количество компаний, в которых работал сотрудник
22. Over18 - Старше ли сотрудник 18 лет (одно уникальное значение - “Y”, так как по законодательству США разрешенный возраст начала трудовой деятельности - 18 лет)
23. OverTime - Работает ли сотрудник сверхурочно
24. PercentSalaryHike - Процентное увеличение заработной платы
25. PerformanceRating - Рейтинг производительности
26. RelationshipSatisfaction - Удовлетворенность отношениями в рабочей среде
27. StandardHours - Количество рабочих часов (одно уникальное значение - 80)
28. StockOptionLevel - Опционы на акции сотрудников (вид компенсации акционерного капитала, предоставляемой компаниями своим сотрудникам и руководителям)
29. TotalWorkingYears - Количество отработанных лет, трудовой стаж
30. TrainingTimesLastYear - Количество часов, потраченных на обучение в прошлом году
31. WorkLifeBalance - Баланс между работой и личной жизнью
32. YearsAtCompany - Количество лет, отработанных в данной компании
33. YearsInCurrentRole - Количество лет в данной должности
34. YearsSinceLastPromotion - Количество лет, прошедших с момента последнего повышения в должности
35. YearsWithCurrManager - Количество лет, проведенных с текущим руководителем

## 2.3 Вычисляем количество пропущенных значений
"""

df.isnull().sum()

"""Видим, что в представленном наборе данных нет пропущенных значений, поэтому можем переходить к следующему шагу, а именно к анализу на наличие дубликатов в данных.

## 2.4 Проводим анализ на наличие дубликатов в данных

Создадим отдельную переменную duplicates, в которой будет храниться результат проверки на дубликаты. Эта переменная будет иметь значение True, если данные содержат повторяющиеся строки, и False в противном случае.
"""

duplicates = df.duplicated().any()
duplicates

"""После проведенной проверки видим, что в переменной duplicates сохранилось значение False, что говорит об отсутствии дубликатов в данных и необходимости их удаления.

## 2.5 Определяем числовые и категориальные признаки

Сохраняем названия числовых и категориальных признаков в отдельные переменные.
"""

numerical = df.select_dtypes(include = 'number').columns.tolist()
categorical = df.select_dtypes(exclude = 'number').columns.tolist()

numerical

categorical

"""## 2.6 Приводим категориальные признаки к числовой классификации"""

le = LabelEncoder()

l1 = []
l2 = []
names_categorical = []

df1 = df.copy(deep = True)

for i in categorical:
  if type(df1[i][0]) == str:
    names_categorical.append(i)
    df1[i] = le.fit_transform(df1[i])
    l1.append(list(df1[i].unique())); l2.append(list(le.inverse_transform(df1[i].unique())))
    print(i,' : ',df1[i].unique(),' = ',le.inverse_transform(df1[i].unique()))

"""Мы сохранили ключи и их значения в отдельные списки l1 и l2, поэтому при необходимости для уточнения значения того или иного ключа мы можем к ним вернуться."""

l1

l2

names_categorical

"""## 2.7 Создаем словарь, который дает информацию о закодированном значении и его исходном значении"""

categories_info = {}
for i in range(len(names_categorical)):
    categories_info[names_categorical[i]] = {}
    for j, k in zip(l1[i], l2[i]):
        categories_info[names_categorical[i]][j] = k

categories_info

"""## 2.8 Получаем основные статистические характеристики числовых данных"""

df[numerical].describe()

df[numerical].hist(figsize=(20,20), xrot=-45)
plt.show()

"""* В столбце 'EmployeeCount' одно уникальное значение - 1.0.
* В столбце 'StandardHours' все значения - 80.0.
* Столбец 'EmployeeNumber' - идентификационный номер сотрудника, который совпадает с индексом каждой строки.

Таким образом, представленные выши признаки не являются статистически значимыми.

В столбцах 'Education', 'JobLevel' - пять уникальных значений (от 1 до 5), 'EnvironmentSatisfaction', 'JobInvolvement', 'JobSatisfaction', 'RelationshipSatisfaction', 'WorkLifeBalance' - четыре уникальных значения (от 1 до 4), 'StockOptionLevel' - четыре уникальных значения (от 0 до 3),'PerformanceRating' - два уникальных значения (3 и 4). Данное наблюдение может говорить о том, что данные признаки по сути являются категориальными, но предварительно уже были приведены в числовой вид.

Видим, что представленные числовые данные не содержат никаких аномалий, поэтому не нужно выполнять предварительную обработку для данных признаков.

## 2.9 Получаем основные статистические характеристики числовых данных
"""

df[categorical].describe()

df1[categorical].describe()

"""Также для наглядности и проверки на аномалии рассчитаем соотношение между нечисловыми значениями."""

value_ratios_dictionary = {}
for i in categorical:
  value_ratios_dictionary[i] = dict(df[i].value_counts(normalize=True) * 100)
value_ratios_dictionary

value_ratios_df = pd.DataFrame({'value_ratios': value_ratios_dictionary})
value_ratios_df = value_ratios_df.transpose()[categorical]
value_ratios_df.head()

df1[categorical].hist(figsize=(20,20), xrot=-45)
plt.show()

"""Как и числовые данные, нечисловые данные не имеют каких-либо аномалий. Признак "Over18" имеет только одно значение "Y", указывающее на то, что все сотрудники в наборе данных старше 18 лет.

# **3. Нахождение взаимосвязей в данных**

## 3.1 Вычислим соотношение между мужчинами и женщинами
"""

df_gender = df.copy()
df_gender = df_gender['Gender'].value_counts()
df_gender

fig_gender = make_subplots(rows=1, cols=2, specs=[[{"type": "pie"},{"type": "pie"}]],subplot_titles=('',''))
fig_gender.add_trace(go.Pie(values = df_gender.values, labels = df_gender.index, hole=0.7, marker_colors=["#19D3F3", "#FF6692"]),row=1,col=1)
fig_gender.update_layout(title ={'text' : "<b>Гендерное соотношение сотрудников</b>",
                          'x' : 0.21})
fig_gender.update_traces(marker=dict(line=dict(color='#000000', width=1)))
fig_gender.show()

"""Количество мужчин в компании составляет более высокую долю, чем женщин (на 20% больше).

## 3.2 Вычислим соотношение увольняющихся и остающихся сотрудников
"""

att1=df.groupby('Attrition',as_index=False)['Age'].count()
att1['Count']=att1['Age']
att1.drop('Age',axis=1,inplace=True)
att2=df.groupby(['Gender','Attrition'],as_index=False)['Age'].count()
att2['Count']=att2['Age']
att2.drop('Age',axis=1,inplace=True)
fig=go.Figure()
fig=make_subplots(rows=1,cols=3)
fig = make_subplots(rows=1, cols=3, specs=[[{"type": "pie"}, {"type": "pie"}, {"type": "pie"}]],subplot_titles=('<b>Текучесть кадров', '<b>Текучесть кадров среди женщин','<b>Текучесть кадров среди мужчин'))
fig.add_trace(go.Pie(values=att1['Count'],labels=att1['Attrition'],hole=0.7,marker_colors=['#00CC96','#EF553B'],name='Текучесть кадров',showlegend=False),row=1,col=1)
fig.add_trace(go.Pie(values=att2[(att2['Gender']=='Female')]['Count'],labels=att2[(att2['Gender']=='Female')]['Attrition'],hole=0.7,marker_colors=['#00CC96','#EF553B'],name='Текучесть кадров среди женщин',showlegend=False),row=1,col=2)
fig.add_trace(go.Pie(values=att2[(att2['Gender']=='Male')]['Count'],labels=att2[(att2['Gender']=='Male')]['Attrition'],hole=0.7,marker_colors=['#00CC96','#EF553B'],name='Текучесть кадров среди мужчин',showlegend=True),row=1,col=3)
fig.update_traces(marker=dict(line=dict(color='#000000', width=1)))
fig

"""Текучесть кадров данной организации составляет 16.1%. Традиционно нормальной текучестью персонала считается показатель в 3-5 %. Если процент увольнений составляет 5-9 %, это свидетельствует об относительной стабильности коллектива.
Таким образом, можно сделать вывод, что текучесть кадров находится на опасном уровне и следует предпринять какие-то меры.
Также по данному графику мы видим, что женщины увольняются реже мужчин, что может говорить о том, что женщины более стабильны и имеют более низкие стандарты относительно карьеры.

## 3.3 Рассмотрим распределение по возрасту
"""

mean_age = round(df['Age'].mean(), 2)
mean_age

plt.figure(figsize=(8,5))
sns.kdeplot(x = df['Age'], color = '#FF97FF', shade  =True, label = 'Возраст')
plt.axvline(x= df['Age'].mean(), color = 'black', linestyle = "--", label = 'Средний возраст: 36.92')
plt.legend()
plt.title('Распределение по возрасту')
plt.show()

"""Согласно данному графику, средний возраст сотрудника в компании составляет 36.92 лет. Наибольшая доля сотрудников приходится на возраст в диапазоне от 30 до 40 лет, что, в целом, является разумным распределением, поскольку сотрудники в таком возрасте являются наиболее продуктивными.

## 3.4 Рассмотрим распределение по заработной плате
"""

average_monthly_income = round(df['MonthlyIncome'].mean(), 2)
average_monthly_income

plt.figure(figsize=(8,5))
sns.kdeplot(x = df['MonthlyIncome'], color = '#FF97FF',shade = True, label = 'Ежемесячный доход')
plt.axvline(x = df['MonthlyIncome'].mean(), color = 'black', linestyle = "--", label = 'Средний ежемесячный доход: 6502.93')
plt.legend()
plt.title('Распределение по ежемесячному доходу')
plt.show()

"""Согласно данному графику, средний ежемесячный доход в компании составляет 6502.93.

## 3.5 Возрастное распределение текучести кадров по полу
"""

fig, axes = plt.subplots(1, 2, sharex=True, figsize=(15,4))
fig.suptitle('Возрастное распределение текучести кадров по полу')
sns.kdeplot(ax=axes[0],x=df[(df['Gender']=='Male')&(df['Attrition']=='Yes')]['Age'], color='#EF553B', shade=True, label='Да')
sns.kdeplot(ax=axes[0],x=df[(df['Gender']=='Male')&(df['Attrition']=='No')]['Age'], color='#00CC96', shade=True, label='Нет')
axes[0].set_title('Мужчины')
axes[0].legend(title='Увольнение')
sns.kdeplot(ax=axes[1],x=df[(df['Gender']=='Female')&(df['Attrition']=='Yes')]['Age'], color='#EF553B', shade=True, label='Да')
sns.kdeplot(ax=axes[1],x=df[(df['Gender']=='Female')&(df['Attrition']=='No')]['Age'], color='#00CC96', shade=True, label='Нет')
axes[1].set_title('Женщины')
axes[1].legend(title='Увольнение')
plt.show()

"""По данному графику мы видим, что наибольшее количество мужчин и женщин увольняется в возрасте около 30 лет.

Также используем боксплот для более наглядной визуализации возрастного распределения текучести кадров по полу.
"""

fig=px.box(df,x='Gender',y='Age',color='Attrition',template='simple_white',color_discrete_sequence=['#EF553B','#00CC96'])
fig.update_traces(marker=dict(line=dict(color='#000000', width=0.5)))
fig.update_xaxes(visible=True)
fig.update_yaxes(visible=True)
fig.update_layout(title_x=0.5,template='simple_white', legend_title_text='<b>Увольнение', showlegend=True,title_text='<b>Возрастное распределение текучести кадров по полу</b>',font_family="Times New Roman",title_font_family="Times New Roman")
fig.show()

"""По данному графику видим, что женщины и мужчины в среднем увольняются примерно в одно и то же время - женщины в 31 год, мужчины в 32.

## 3.6 Распределение заработной платы при увольнении по полу
"""

fig, axes = plt.subplots(1, 2, sharex=True, figsize=(15,4))
fig.suptitle('Распределение ежемесячного дохода при увольнении по полу')
sns.kdeplot(ax=axes[0],x=df[(df['Gender']=='Male')&(df['Attrition']=='Yes')]['MonthlyIncome'], color='#EF553B', shade=True, label='Да')
sns.kdeplot(ax=axes[0],x=df[(df['Gender']=='Male')&(df['Attrition']=='No')]['MonthlyIncome'], color='#00CC96', shade=True, label='Нет')
axes[0].set_title('Мужчины')
axes[0].legend(title='Увольнение')
sns.kdeplot(ax=axes[1],x=df[(df['Gender']=='Female')&(df['Attrition']=='Yes')]['MonthlyIncome'], color='#EF553B', shade=True, label='Да')
sns.kdeplot(ax=axes[1],x=df[(df['Gender']=='Female')&(df['Attrition']=='No')]['MonthlyIncome'], color='#00CC96', shade=True, label='Нет')
axes[1].set_title('Женщины')
axes[1].legend(title='Увольнение')
plt.show()

"""Рассмотрим также данный показатель с помощью графика боксплот."""

fig=px.box(df,x='Gender',y='MonthlyIncome',color='Attrition',template='simple_white',color_discrete_sequence=['#EF553B','#00CC96'])
fig.update_traces(marker=dict(line=dict(color='#000000', width=0.5)))
fig.update_xaxes(visible=True)
fig.update_yaxes(visible=True)
fig.update_layout(title_x=0.5,template='simple_white', legend_title_text='<b>Увольнение', showlegend=True,title_text='<b>Распределение ежемесячного дохода при увольнении по полу',font_family="Times New Roman",title_font_family="Times New Roman")
fig.show()

"""По данному графику мы видим, что и мужчины, и женщины чаще всего увольняются тогда, когда их ежемесячный доход меньше 5000.
Также мы видим, что медианное значение при увольнении чуть меньше, чем у мужчин (2886 у женщин против 3407.5 у мужчин). Возможно, это связано с тем, что заработок женщины обычно ниже заработка мужчин.
"""

fig, axes = plt.subplots(1, 2, sharex=True, figsize=(15,4))
fig.suptitle('Распределение ежемесячной ставки при увольнении по полу')
sns.kdeplot(ax=axes[0],x=df[(df['Gender']=='Male')&(df['Attrition']=='Yes')]['MonthlyRate'], color='#EF553B', shade=True, label='Да')
sns.kdeplot(ax=axes[0],x=df[(df['Gender']=='Male')&(df['Attrition']=='No')]['MonthlyRate'], color='#00CC96', shade=True, label='Нет')
axes[0].set_title('Мужчины')
axes[0].legend(title='Увольнение')
sns.kdeplot(ax=axes[1],x=df[(df['Gender']=='Female')&(df['Attrition']=='Yes')]['MonthlyRate'], color='#EF553B', shade=True, label='Да')
sns.kdeplot(ax=axes[1],x=df[(df['Gender']=='Female')&(df['Attrition']=='No')]['MonthlyRate'], color='#00CC96', shade=True, label='Нет')
axes[1].set_title('Женщины')
axes[1].legend(title='Увольнение')
plt.show()

"""По данному графику мы видим, что и мужчины, и женщины чаще всего увольняются тогда, когда их ежемесячная ставка находится в промежутке от 10000 до примерно 25000. Но у мужчин значение склоняется больше к 10000, тогда как у женщин значение склоняется больше к 20000, что говорит о том, что женщины увольняются позже и, возможно, низкий доход беспокоит их не так сильно, как мужчин."""

fig, axes = plt.subplots(1, 2, sharex=True, figsize=(15,5))
fig.suptitle('Распределение ежедневной ставки при увольнении по полу')
sns.kdeplot(ax=axes[0],x=df[(df['Gender']=='Male')&(df['Attrition']=='Yes')]['DailyRate'], color='#EF553B', shade=True, label='Да')
sns.kdeplot(ax=axes[0],x=df[(df['Gender']=='Male')&(df['Attrition']=='No')]['DailyRate'], color='#00CC96', shade=True, label='Нет')
axes[0].set_title('Мужчины')
axes[0].legend(title='Увольнение')
sns.kdeplot(ax=axes[1],x=df[(df['Gender']=='Female')&(df['Attrition']=='Yes')]['DailyRate'], color='#EF553B', shade=True, label='Да')
sns.kdeplot(ax=axes[1],x=df[(df['Gender']=='Female')&(df['Attrition']=='No')]['DailyRate'], color='#00CC96', shade=True, label='Нет')
axes[1].set_title('Женщины')
axes[1].legend(title='Увольнение')
plt.show()

"""По данному графику мы видим, что мужчины чаще всего увольняются тогда, когда их ежедневная ставка составляет около 400, тогда как у женщин это значение составляет чуть более 500. Данные наблюдения могут говорить о том, что зарплатные ожидания женщин ниже, чем у мужчин, и низкий доход не беспокоит их так сильно, как мужчин.

## 3.7 Распределение текучести кадров по позиции в компании
"""

df_level = df.copy()
df_level['JobLevel'] = pd.Categorical(
    df_level['JobLevel']).rename_categories(
    ['Начинающие специалисты', 'Средний уровень', 'Старшие специалисты', 'Руководители', 'Управляющие'])

df_level= df_level['JobLevel'].value_counts()

colors = ["#E2E2E2","#F7E1A0","#FEAF16","#FF7F0E","#DC3912"]
data = go.Bar(x=df_level.index, y = df_level.values, text = df_level.values , textposition ='inside',
              textfont = dict(size = 12,
                             color = 'black'),
              marker = dict(color = colors,
                            opacity = 0.7,
                            line_color = 'black',
                            line_width = 2))
layout = go.Layout(title = {'text': "<b>Распределение текучести кадров по позиции в компании</b>",
                           'x':0.5,
                           'xanchor': 'center'},
                   xaxis = dict(title='<b>Позиция</b>'),
                   yaxis =dict(title='<b>Количество сотрудников</b>'),
                   width = 900,
                   height = 600,
                   template = 'plotly_white')
fig=go.Figure(data = data, layout = layout)
fig

"""На столбчатой диаграмме выше мы видим:

Большая доля увольняющихся сотрудников приходится на уровень 1 (начинающие специалисты), которые в силу возраста склонны чаще менять работу. Это может быть обусловлено тем, что, набираясь опыта, молодые люди уходят в другие компании на более выгодных условиях.

Сотрудники уровня 2 (средний уровень) также имеют относительно высокую текучесть кадров, что обусловлено возрастом сотрудников и приобретением ими опыта.

Сотрудники, достигшие уровня 3 (старшие специалисты), 4 (руководители) и 5 (управляющие), увольняются гораздо реже.

Таким образом, из полученных наблюдений можно сделать вывод, что молодые сотрудники, только что пришедшие в компанию, имеют наибольшую склонность к увольнению в сравнению с другими позициями.

## 3.8 Текучесть кадров в зависимости от должностных позиций
"""

df_role=df.groupby(['JobRole','Attrition'],as_index=False)['Age'].count()
a=df_role[df_role['Attrition']=='Yes']
b=df_role[df_role['Attrition']=='No']
a['Age']=a['Age'].apply(lambda x: -x)
df_role=pd.concat([a,b],ignore_index=True)
df_role['Count']=df_role['Age']
df_role.rename(columns={'JobRole':'Должностная позиция', 'Count': 'Количество', 'Attrition': 'Текучесть кадров'},inplace=True)
fig=px.bar(df_role,x='Должностная позиция',y='Количество',color='Текучесть кадров',template='simple_white',text='Количество',color_discrete_sequence=['#EF553B', '#00CC96'])
fig.update_yaxes(range=[-200,300])
fig.update_traces(marker=dict(line=dict(color='#000000', width=1)),textposition = "outside")
fig.update_xaxes(visible=True)
fig.update_yaxes(visible=True)
fig.update_layout(title_x=0.5,template='simple_white',showlegend=True,title_text='<b style="color:black; font-size:105%;">Текучесть кадров в зависимости от должностных позиций</b>',font_family="Times New Roman",title_font_family="Times New Roman")
fig.show()

"""Согласно столбчатой диаграмме выше, наиболее представлены в компании руководители отдела продаж (Sales Executive), научные сотрудники (Research Scientist) и техники-лаборанты (Laboratory Technician).

Должностные позиции, наиболее склонные к увольнению — руководители отдела продаж (Sales Executive), торговые представители (Sales Representative), техники-лаборанты (Laboratory Technician) и научные сотрудники (Research Scientist). Должностные позиции, наименее склонные к увольнению — директора по исследованиям (Research Director), менеджеры (Manager) и представители здравоохранения (Healthcare Representative).

## 3.9 Распределение сотрудников, склонных к сверхурочной работе, по должностям

Из отчета выше можно выдвинуть предположение, что сотрудники, занимающие те или позиции, склонны чаще увольняться из-за третьих факторов. Возможно, таким фактором может послужить сверхурочная работа.
"""

df_overtime = df.copy()
df_overtime.rename(columns={'JobRole':'Должностная позиция', 'OverTime': 'Cверхурочная работа'},inplace=True)
fig = px.histogram(df_overtime, x = 'Должностная позиция', color = 'Cверхурочная работа',
                 width=1000, height=500, template="simple_white", color_discrete_sequence=['#FE00CE', '#FED4C4'])
fig.update_traces(marker=dict(line=dict(color='#000000', width=1)))
fig.update_layout(
    title={
        'text': "Распределение сотрудников, склонных к сверхурочной работе, по должностям",
        'y':0.9,
        'x':0.5,
        'xanchor': 'center',
        'yanchor': 'top'})
fig.show()

"""Согласно данному графику мы видим, что около трети всех сотрудников привыкли работать сверхурочно. Наибольший процент (около 28%) у должностных позиций, наиболее склонных к увольнению — руководители отдела продаж (Sales Executive), торговые представители (Sales Representative), техники-лаборанты (Laboratory Technician) и научные сотрудники (Research Scientist). Таким образом, корреляция между уровнем сверхурочной работы и увольнением точно имеется.

## 3.10 Влияние деловых поездок на увольнение сотрудников
"""

df_travel=df.groupby(['BusinessTravel','Attrition'],as_index=False)['Age'].count()
df_travel['Count'] = df_travel['Age']
df_travel.drop('Age',axis=1,inplace=True)

fig=go.Figure()
fig = make_subplots(rows=1, cols=3, specs=[[{"type": "pie"}, {"type": "pie"}, {"type": "pie"}]],subplot_titles=('Не путешествуют', 'Путешествуют часто','Путешествуют редко'))

fig.add_trace(go.Pie(values=df_travel[df_travel['BusinessTravel']=='Non-Travel']['Count'],labels=df_travel[df_travel['BusinessTravel']=='Non-Travel']['Attrition'],hole=0.7,marker_colors=['#00CC96','#EF553B'],name='Не путешествуют',showlegend=False),row=1,col=1)
fig.add_trace(go.Pie(values=df_travel[df_travel['BusinessTravel']=='Travel_Frequently']['Count'],labels=df_travel[df_travel['BusinessTravel']=='Travel_Frequently']['Attrition'],hole=0.7,marker_colors=['#00CC96','#EF553B'],name='Путешествуют часто',showlegend=False),row=1,col=2)
fig.add_trace(go.Pie(values=df_travel[df_travel['BusinessTravel']=='Travel_Rarely']['Count'],labels=df_travel[df_travel['BusinessTravel']=='Travel_Rarely']['Attrition'],hole=0.7,marker_colors=['#00CC96','#EF553B'],name='Путешествуют редко',showlegend=True),row=1,col=3)

fig.update_layout(title_x=0.5,template='simple_white',showlegend=True,legend_title_text="<b>Увольнение",title_text='<b>Влияние деловых поездок на увольнение сотрудников',font_family="Times New Roman",title_font_family="Times New Roman")
fig.update_traces(marker=dict(line=dict(color='#000000', width=1)))
fig.show()

"""На данных графиках мы видим четкую корреляцию между количеством деловых поездок и степенью текучести кадров. Возможно, это связано с тем, что сотрудники, имеющие множество деловых поездок, меньше бывают дома и больше устают, что приводит к выгоранию и демотивации.

## 3.11 Влияние месячной заработной платы на увольнение сотрудников разных уровней
"""

df_salary_levels = df.copy()
df_salary_levels['JobLevel'] = pd.Categorical(
    df_salary_levels['JobLevel']).rename_categories(
    ['Начинающие специалисты', 'Средний уровень', 'Старшие специалисты', 'Руководители', 'Управляющие'])
fig=px.box(df_salary_levels,x='JobLevel',y='MonthlyIncome',color='Attrition',template='simple_white',color_discrete_sequence=['#EF553B','#00CC96'])
fig.update_traces(marker=dict(line=dict(color='#000000', width=0.5)))
fig.update_xaxes(visible=True)
fig.update_yaxes(visible=True)
fig.update_layout(title_x=0.5,template='simple_white', legend_title_text='<b>Увольнение', showlegend=True,title_text='<b>Влиянение месячной заработной платы на увольнение сотрудников',font_family="Times New Roman",title_font_family="Times New Roman")
fig.show()

"""Очевидно, что чем выше должность, тем выше зарплатные ожидания, поэтому на данном графике мы видим четкую корреляцию между должностью и уровнем заработной платы, при которой сотрудники обычно меняют работу. У начинающих спецалистов медианное значение составляет 2437, у сотрудников среднего уровня - 5346, у старших специалистов - 9887, у руководителей - 13194, у управляющих - 19545.
Таким образом, на основе представленных данных можно спрогнозировать увольнение сотрудников и вовремя предложить им большую заработную плату для удержания в компании.

## 3.12 Изменение заработной платы в зависимости от срока работы в компании
"""

df_years=df.copy()
conditions=[(df_years['YearsAtCompany']>=0) & (df_years['YearsAtCompany']<=5),
            (df_years['YearsAtCompany']>5) & (df_years['YearsAtCompany']<=10),
            (df_years['YearsAtCompany']>10) & (df_years['YearsAtCompany']<=15),
            (df_years['YearsAtCompany']>15) & (df_years['YearsAtCompany']<=20),
            (df_years['YearsAtCompany']>20) & (df_years['YearsAtCompany']<=25),
            (df_years['YearsAtCompany']>25) & (df_years['YearsAtCompany']<=30),
            (df_years['YearsAtCompany']>30) & (df_years['YearsAtCompany']<=35),
            (df_years['YearsAtCompany']>35) & (df_years['YearsAtCompany']<=40)]
values=['0-5','05-10','10-15','15-20','20-25','25-30','30-35','35-40']
df_years['YearsRange']=np.select(conditions, values)
df_years['YearsRange']

df_salary_change=df_years.groupby(['YearsRange'])['MonthlyIncome'].mean().reset_index()
sns.set(rc={"axes.facecolor":"#B6E880","figure.facecolor":"white"})
sns.set_context("poster",font_scale = .7)
plt.subplots(figsize=(20,8))
p=sns.lineplot(x=df_salary_change["YearsRange"] ,y=df_salary_change["MonthlyIncome"],data=df_salary_change,color="#2CA02C",marker="o",linewidth=5,markersize=16,markerfacecolor="#D62728")
p.axes.set_title("Зависимость между месячным доходом и количеством лет в компании", family ='Times New Roman')
p.axes.set_xlabel("Количество отработанных лет в компании", family ='Times New Roman')
p.axes.set_ylabel("Месячный доход", family ='Times New Roman')
sns.despine(left=True, bottom=True)
plt.show()

"""На основании представленного выше линейного графика можно сделать вывод, что в период работы в компании от 0 до 35 лет средняя заработная плата сотрудников постепенно увеличивается с течением времени. Это объясняется тем, что при длительной работе в компании сотрудники набираются опыта, что поощряется компанией.
Однако можно заметить еще одну интересную тенденцию - заработная плата в период работы с 35-40 лет немного уменьшается. Причина такого снижения может заключаться в том, что при стаже работы в компании 35-40 лет эти сотрудники приближаются к пенсионному возрасту, поэтому их производительность снижается или они уступают руководящие должности более молодым сотрудникам.

## 3.13 Ежемесячный доход по общему количеству лет работы и занимаемой должности

Данный график объединит в себе предыдущий график (рост доходов в зависимости от проведенных в компании лет) и дополнительную информацию о занимаемой должности.
"""

df_years_rank = df.copy()
df_years_rank['JobLevel'] = pd.Categorical(
    df_years_rank['JobLevel']).rename_categories(
    ['Начинающие специалисты', 'Средний уровень', 'Старшие специалисты', 'Руководители', 'Управляющие'])
colors = ["#E2E2E2","#F7E1A0","#FEAF16","#FF7F0E","#DC3912"]
fig = px.scatter(df_years_rank, x='TotalWorkingYears', y='MonthlyIncome',
                 color='JobLevel', size='MonthlyIncome',
                 color_discrete_sequence=colors,
                 category_orders={'JobLevel': ['Начинающие специалисты', 'Средний уровень', 'Старшие специалисты', 'Руководители', 'Управляющие']})
fig.update_layout(legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
                  title='<b>Месячный доход по общему количеству лет работы и занимаемой должности',
                  title_font = dict(size = 20, family ='Times New Roman'),
                  xaxis_title='<b>Время работы в компании', yaxis=dict(title='<b>Месячный доход',tickprefix='$'),
                  legend_title='',
                  margin=dict(l=40, r=30, b=80, t=120),paper_bgcolor='#F4F2F0', plot_bgcolor='#F4F2F0',
                  height = 500,
                  width = 1000)
fig.show()

"""Согласно представленной выше диаграмме, можно сделать простой вывод: чем выше должность, тем больше ежемесячный доход. Начинающие специалисты и специалисты на среднем уровне обычно работают от 0 до 20 лет. Чтобы иметь возможность занимать высшую руководящую должность (уровень называется "Управляющие"), необходимо проработать более 20 лет, даже более 35 лет.

## 3.14 Уровень текучести кадров в зависимости от временных параметров

В данном блоке рассмотрим такие параметры, как количество лет в компании ('YearsAtCompany'), количество лет в данной должности ('YearsInCurrentRole'), количество лет с момента последнего повышения в должности ('YearsSinceLastPromotion'), количество лет, проведенных с текущим менеджером ('YearsWithCurrManager').
"""

fig=go.Figure()
fig=make_subplots(rows=2,cols=2)
years_1=df.groupby(['YearsAtCompany','Attrition'],as_index=False)['Age'].count()
years_1['Count']=years_1['Age']
years_1.drop(columns='Age',axis=1,inplace=True)
years_2=df.groupby(['YearsInCurrentRole','Attrition'],as_index=False)['Age'].count()
years_2['Count']=years_2['Age']
years_2.drop(columns='Age',axis=1,inplace=True)
years_3=df.groupby(['YearsSinceLastPromotion','Attrition'],as_index=False)['Age'].count()
years_3['Count']=years_3['Age']
years_3.drop(columns='Age',axis=1,inplace=True)
years_4=df.groupby(['YearsWithCurrManager','Attrition'],as_index=False)['Age'].count()
years_4['Count']=years_4['Age']
years_4.drop(columns='Age',axis=1,inplace=True)

fig.add_trace(go.Bar(x=years_1[years_1['Attrition']=='Yes']['YearsAtCompany'], y=years_1[years_1['Attrition']=='Yes']['Count'],name='Да',marker_color='#EF553B',showlegend=False),row=1,col=1)
fig.add_trace(go.Bar(x=years_1[years_1['Attrition']=='No']['YearsAtCompany'], y=years_1[years_1['Attrition']=='No']['Count'],name='Нет',marker_color='#00CC96',showlegend=False),row=1,col=1)
fig.add_trace(go.Bar(x=years_2[years_2['Attrition']=='Yes']['YearsInCurrentRole'], y=years_2[years_2['Attrition']=='Yes']['Count'],name='Да',marker_color='#EF553B',showlegend=True),row=1,col=2)
fig.add_trace(go.Bar(x=years_2[years_2['Attrition']=='No']['YearsInCurrentRole'], y=years_2[years_2['Attrition']=='No']['Count'],name='Нет',marker_color='#00CC96',showlegend=True),row=1,col=2)
fig.add_trace(go.Bar(x=years_3[years_3['Attrition']=='Yes']['YearsSinceLastPromotion'], y=years_3[years_3['Attrition']=='Yes']['Count'],name='Да',marker_color='#EF553B',showlegend=False),row=2,col=1)
fig.add_trace(go.Bar(x=years_3[years_3['Attrition']=='No']['YearsSinceLastPromotion'], y=years_3[years_3['Attrition']=='No']['Count'],name='Нет',marker_color='#00CC96',showlegend=False),row=2,col=1)
fig.add_trace(go.Bar(x=years_4[years_4['Attrition']=='Yes']['YearsWithCurrManager'], y=years_4[years_4['Attrition']=='Yes']['Count'],name='Да',marker_color='#EF553B',showlegend=False),row=2,col=2)
fig.add_trace(go.Bar(x=years_4[years_4['Attrition']=='No']['YearsWithCurrManager'], y=years_4[years_4['Attrition']=='No']['Count'],name='Нет',marker_color='#00CC96',showlegend=False),row=2,col=2)
fig.update_xaxes(title_text="<b>Количество лет в компании ", title_font_family="Times New Roman",row=1, col=1)
fig.update_xaxes(title_text="<b>Количество лет в данной должности",title_font_family="Times New Roman", row=1, col=2)
fig.update_xaxes(title_text="<b>Количество лет с момента последнего повышения в должности", title_font_family="Times New Roman",row=2, col=1)
fig.update_xaxes(title_text="<b>Количество лет, проведенных с текущим менеджером", title_font_family="Times New Roman",row=2, col=2)
fig.update_layout(title_x=0.5,template='simple_white',showlegend=True,legend_title_text="<b>Увольнение",title_text='<b>Уровень текучести кадров в зависимости от временных параметров',font_family="Times New Roman",title_font_family="Times New Roman")
fig.update_yaxes(title_text="<b>Количество", title_font_family="Times New Roman",row=1, col=1)
fig.update_yaxes(title_text="<b>Количество", title_font_family="Times New Roman",row=2, col=1)
fig.update_traces(marker=dict(line=dict(color='#000000', width=1.2)))

fig.add_annotation(x=0.428,
                   y=0.528,
                   text=">",
                   showarrow=False,
                   xref="paper",
                   yref="paper",)
fig.show()

"""С увеличением количества лет, проведенных в компании и прошедших с момента последнего продвижения по службе, коэффициент текучести кадров уменьшается. Вполне вероятно, что есть связь с предыдущим графиком, то есть при увеличении стажа растет зарплата сотрудников, что повышает вероятность того, что сотрудники останутся в компании надолго.
По графикам "Количество лет в данной должности" и "Количество лет, проведенных с текущим менеджером" мы видим, что в период с 5 до 10 отработанных в компании лет происходит скачок в увольнениях,что может свидетельствовать о кризисе в коллективе. Многие психологи считают, что менять работу стоит каждые 5-7 лет. Возможно, ситуация на данных графиках свидетельствует именно об этом.

## 3.15 Удовлетворенность сотрудников различными сферами в рабочей среде
"""

df_satisfaction = df.copy()
df_satisfaction['EnvironmentSatisfaction'] = pd.Categorical(
    df_satisfaction['EnvironmentSatisfaction']).rename_categories(
    ['Низкий уровень', 'Средний уровень', 'Высокий уровень', 'Очень высокий уровень'])
df_satisfaction['JobSatisfaction'] = pd.Categorical(
    df_satisfaction['JobSatisfaction']).rename_categories(
    ['Низкий уровень', 'Средний уровень', 'Высокий уровень', 'Очень высокий уровень'])
df_satisfaction['RelationshipSatisfaction'] = pd.Categorical(
    df_satisfaction['RelationshipSatisfaction']).rename_categories(
    ['Низкий уровень', 'Средний уровень', 'Высокий уровень', 'Очень высокий уровень'])

fig=go.Figure()
fig = make_subplots(rows=1, cols=3, specs=[[{"type": "pie"}, {"type": "pie"}, {"type": "pie"}]],subplot_titles=('<b>Удовлетворенность окружающей средой', '<b>Удовлетворенность работой','<b>Удовлетворенность взаимоотношениями'))
fig.add_trace(go.Pie(values=df_satisfaction.groupby(['EnvironmentSatisfaction'],as_index=False)['Age'].count()['Age'],labels=df_satisfaction.groupby(['EnvironmentSatisfaction'],as_index=False)['Age'].count()['EnvironmentSatisfaction'],hole=0.7,marker_colors=['DeepSkyBlue','LightSalmon','LightCoral','PaleGreen'],name='Environment Satisfaction',showlegend=False),row=1,col=1)
fig.add_trace(go.Pie(values=df_satisfaction.groupby(['JobSatisfaction'],as_index=False)['Age'].count()['Age'],labels=df_satisfaction.groupby(['JobSatisfaction'],as_index=False)['Age'].count()['JobSatisfaction'],hole=0.7,marker_colors=['DeepSkyBlue','LightSalmon','LightCoral','PaleGreen'],name='Environment Satisfaction',showlegend=False),row=1,col=2)
fig.add_trace(go.Pie(values=df_satisfaction.groupby(['RelationshipSatisfaction'],as_index=False)['Age'].count()['Age'],labels=df_satisfaction.groupby(['RelationshipSatisfaction'],as_index=False)['Age'].count()['RelationshipSatisfaction'],hole=0.7,marker_colors=['DeepSkyBlue','LightSalmon','LightCoral','PaleGreen'],name='Relationship Satisfaction',showlegend=True),row=1,col=3)
fig.update_traces(textposition='outside', textinfo='percent')

fig.update_layout(title_x=0.5,template='simple_white',showlegend=True,legend_title_text="<b>Уровень удовлетворенности",title_text='<b>Анализ удовлетворенности сотрудников',font_family="Times New Roman",title_font_family="Times New Roman")
fig.update_traces(marker=dict(line=dict(color='#000000', width=1)))

"""Далее рассмотрим уровень текучести сотрудников на основе удовлетворенности работой."""

df_job_satisfaction=df.groupby(['JobSatisfaction','Attrition'],as_index=False)['Age'].count()
df_job_satisfaction['Count']=df_job_satisfaction['Age']
df_job_satisfaction.drop('Age',axis=1,inplace=True)

df_job_satisfaction['JobSatisfaction'] = pd.Categorical(
    df_job_satisfaction['JobSatisfaction']).rename_categories(
    ['Низкий уровень', 'Средний уровень', 'Высокий уровень', 'Очень высокий уровень'])

fig=go.Figure()
fig=make_subplots(rows=1,cols=4)
fig = make_subplots(rows=1, cols=4, specs=[[{"type": "pie"}, {"type": "pie"},{"type": "pie"}, {"type": "pie"}]],subplot_titles=('<b>Очень высокий уровень', '<b>Высокий уровень','<b>Средний уровень','<b>Низкий уровень'))
fig.add_trace(go.Pie(values=df_job_satisfaction[df_job_satisfaction['JobSatisfaction']=='Очень высокий уровень']['Count'],labels=df_job_satisfaction[df_job_satisfaction['JobSatisfaction']=='Очень высокий уровень']['Attrition'],hole=0.7,marker_colors=['#00CC96','#EF553B'],name='Очень высокий уровень',showlegend=False),row=1,col=1)
fig.add_trace(go.Pie(values=df_job_satisfaction[df_job_satisfaction['JobSatisfaction']=='Высокий уровень']['Count'],labels=df_job_satisfaction[df_job_satisfaction['JobSatisfaction']=='Высокий уровень']['Attrition'],hole=0.7,marker_colors=['#00CC96','#EF553B'],name='Высокий уровень',showlegend=False),row=1,col=2)
fig.add_trace(go.Pie(values=df_job_satisfaction[df_job_satisfaction['JobSatisfaction']=='Средний уровень']['Count'],labels=df_job_satisfaction[df_job_satisfaction['JobSatisfaction']=='Средний уровень']['Attrition'],hole=0.7,marker_colors=['#00CC96','#EF553B'],name='Средний уровень',showlegend=False),row=1,col=3)
fig.add_trace(go.Pie(values=df_job_satisfaction[df_job_satisfaction['JobSatisfaction']=='Низкий уровень']['Count'],labels=df_job_satisfaction[df_job_satisfaction['JobSatisfaction']=='Низкий уровень']['Attrition'],hole=0.7,marker_colors=['#00CC96','#EF553B'],name='Низкий уровень',showlegend=True),row=1,col=4)
fig.update_layout(title_x=0.5,template='simple_white',showlegend=True,legend_title_text="<b>Текучесть кадров",title_text='<b>Уровень текучести кадров на основе удовлетворенности работой',font_family="Times New Roman",title_font_family="Times New Roman")
fig.update_traces(marker=dict(line=dict(color='#000000', width=1)))
fig

"""На данных графиках видим отчетливую корреляцию между уровнем удовлетворенности работой и текучестью кадров.

Далее рассмотрим уровень текучести кадров на основе удовлетворенности окружающей средой.
"""

df_environment=df.groupby(['EnvironmentSatisfaction','Attrition'],as_index=False)['Age'].count()
df_environment['Count']=df_environment['Age']
df_environment.drop('Age',axis=1,inplace=True)

df_environment['EnvironmentSatisfaction'] = pd.Categorical(
    df_environment['EnvironmentSatisfaction']).rename_categories(
    ['Низкий уровень', 'Средний уровень', 'Высокий уровень', 'Очень высокий уровень'])

fig=go.Figure()
fig=make_subplots(rows=1,cols=4)
fig = make_subplots(rows=1, cols=4, specs=[[{"type": "pie"}, {"type": "pie"},{"type": "pie"}, {"type": "pie"}]],subplot_titles=('<b>Очень высокий уровень', '<b>Высокий уровень','<b>Средний уровень','<b>Низкий уровень'))
fig.add_trace(go.Pie(values=df_environment[df_environment['EnvironmentSatisfaction']=='Очень высокий уровень']['Count'],labels=df_environment[df_environment['EnvironmentSatisfaction']=='Очень высокий уровень']['Attrition'],hole=0.7,marker_colors=['#00CC96','#EF553B'],name='Очень высокий уровень',showlegend=False),row=1,col=1)
fig.add_trace(go.Pie(values=df_environment[df_environment['EnvironmentSatisfaction']=='Высокий уровень']['Count'],labels=df_environment[df_environment['EnvironmentSatisfaction']=='Высокий уровень']['Attrition'],hole=0.7,marker_colors=['#00CC96','#EF553B'],name='Высокий уровень',showlegend=False),row=1,col=2)
fig.add_trace(go.Pie(values=df_environment[df_environment['EnvironmentSatisfaction']=='Средний уровень']['Count'],labels=df_environment[df_environment['EnvironmentSatisfaction']=='Средний уровень']['Attrition'],hole=0.7,marker_colors=['#00CC96','#EF553B'],name='Средний уровень',showlegend=False),row=1,col=3)
fig.add_trace(go.Pie(values=df_environment[df_environment['EnvironmentSatisfaction']=='Низкий уровень']['Count'],labels=df_environment[df_environment['EnvironmentSatisfaction']=='Низкий уровень']['Attrition'],hole=0.7,marker_colors=['#00CC96','#EF553B'],name='Низкий уровень',showlegend=True),row=1,col=4)
fig.update_layout(title_x=0.5,template='simple_white',showlegend=True,legend_title_text="<b>Текучесть кадров",title_text='<b>Уровень текучести кадров на основе удовлетворенности окружающей средой',font_family="Times New Roman",title_font_family="Times New Roman")
fig.update_traces(marker=dict(line=dict(color='#000000', width=1)))
fig

"""На данных графиках также видим отчетливую корреляцию между уровнем удовлетворенности окружающей средой и текучестью кадров.

Далее рассмотрим уровень текучести кадров на основе удовлетворенности взаимоотношениями.
"""

df_relationship=df.groupby(['RelationshipSatisfaction','Attrition'],as_index=False)['Age'].count()
df_relationship['Count']=df_relationship['Age']
df_relationship.drop('Age',axis=1,inplace=True)

df_relationship['RelationshipSatisfaction'] = pd.Categorical(
    df_relationship['RelationshipSatisfaction']).rename_categories(
    ['Низкий уровень', 'Средний уровень', 'Высокий уровень', 'Очень высокий уровень'])

fig=go.Figure()
fig=make_subplots(rows=1,cols=4)
fig = make_subplots(rows=1, cols=4, specs=[[{"type": "pie"}, {"type": "pie"},{"type": "pie"}, {"type": "pie"}]],subplot_titles=('<b>Очень высокий уровень', '<b>Высокий уровень','<b>Средний уровень','<b>Низкий уровень'))
fig.add_trace(go.Pie(values=df_relationship[df_relationship['RelationshipSatisfaction']=='Очень высокий уровень']['Count'],labels=df_relationship[df_relationship['RelationshipSatisfaction']=='Очень высокий уровень']['Attrition'],hole=0.7,marker_colors=['#00CC96','#EF553B'],name='Очень высокий уровень',showlegend=False),row=1,col=1)
fig.add_trace(go.Pie(values=df_relationship[df_relationship['RelationshipSatisfaction']=='Высокий уровень']['Count'],labels=df_relationship[df_relationship['RelationshipSatisfaction']=='Высокий уровень']['Attrition'],hole=0.7,marker_colors=['#00CC96','#EF553B'],name='Высокий уровень',showlegend=False),row=1,col=2)
fig.add_trace(go.Pie(values=df_relationship[df_relationship['RelationshipSatisfaction']=='Средний уровень']['Count'],labels=df_relationship[df_relationship['RelationshipSatisfaction']=='Средний уровень']['Attrition'],hole=0.7,marker_colors=['#00CC96','#EF553B'],name='Средний уровень',showlegend=False),row=1,col=3)
fig.add_trace(go.Pie(values=df_relationship[df_relationship['RelationshipSatisfaction']=='Низкий уровень']['Count'],labels=df_relationship[df_relationship['RelationshipSatisfaction']=='Низкий уровень']['Attrition'],hole=0.7,marker_colors=['#00CC96','#EF553B'],name='Низкий уровень',showlegend=True),row=1,col=4)
fig.update_layout(title_x=0.5,template='simple_white',showlegend=True,legend_title_text="<b>Текучесть кадров",title_text='<b>Уровень текучести кадров на основе удовлетворенности взаимоотношениями',font_family="Times New Roman",title_font_family="Times New Roman")
fig.update_traces(marker=dict(line=dict(color='#000000', width=1)))
fig

"""На данных графиках мы видим странную тенденцию. На среднем уровне удовлетворенности увольняется меньше сотрудников, чем на высоком. Однако, если сравнивать очень высокий уровень удовлетворенности и низкий, мы увидим, что корреляция между увольнением и уровнем удовлетворенности взаимоотношениями имеется.

## 3.16 Влияние семейного положения на текучесть кадров
"""

df_marital = df.copy()
df_marital.rename(columns={'MaritalStatus':'Семейное положение', 'Attrition': 'Увольнение'},inplace=True)
df_marital['Семейное положение'] = pd.Categorical(
    df_marital['Семейное положение']).rename_categories(
    ['Разведен/разведена', 'Женатый/замужняя', 'Неженатый/незамужняя'])
df_marital['Увольнение'] = pd.Categorical(
    df_marital['Увольнение']).rename_categories(
    ['Нет', 'Да'])
fig = px.histogram(df_marital, x = 'Семейное положение', color = 'Увольнение',
                 width=1000, height=500, template="simple_white", color_discrete_sequence=['#FE00CE', '#FED4C4'])
fig.update_traces(marker=dict(line=dict(color='#000000', width=1)))
fig.update_layout(
    title={
        'text': "Влияние семейного положения на текучесть кадров.",
        'y':0.9,
        'x':0.5,
        'xanchor': 'center',
        'yanchor': 'top'})
fig.show()

"""На основе представленной гистограммы с накоплением можно сделать следующие выводы:

1. Процент сотрудников, состоящих в браке, составляет наибольшее количество,что является логичным, когда средний возраст сотрудников в этой компании составляет около 36 лет.

2. У одиноких сотрудников наблюдается наиболее высокий коэффициент текучести. Молодые люди, у которых нет семьи и определенных связанных с данным обстоятельством обязательств, склонны чаще менять работу и "искать себя".

# **4. Построение модели машинного обучения**

## 4.1 Проблема, которую необходимо решить

Основная задача, которую необходимо решить, - *предсказать, есть ли риск того, что тот или иной сотрудник покинет компанию*.

Для решения данной задачи было решено использовать *логистическую регрессию*, где целевой переменной будут увольнения (признак "Attrition"). Данный метод был выбран по той причине, что требуется доказать бинарную величину (уволится ли сотрудник: 1 (да)/0 (нет)).

Для оценки качества модели была выбрана метрика *accuracy*, так как перед нами стоит задача бинарной классификации.

## 4.2 Предварительная подготовка данных
"""

df_model = df.copy()

"""Фильтруем категориальные признаки."""

df_categories=df_model.select_dtypes(exclude = 'number')
df_categories.head()

"""Посчитаем количество уникальных значений в каждой категории."""

unique_values=[df_categories[i].nunique() for i in list(df_categories.columns)]
unique_values

"""*   Столбец "Over18" содержит только оно уникальное значение, что означает, что этот столбец не повлияет на результаты обучения модели.
*   Категории "Attrition", "Gender" и "OverTime" имеют два разных типа значений, поэтому их следует закодировать, использовав метки "0" и "1".
*   Для признаков, у которых более чем два типа значений, мы будем использовать быстрое кодирование (One-Hot Encoding), чтобы из категорий, которые раньше были строками, сделать столбцы. Это ползволит избежать смещения, вызванного кодированием значений.





"""

df_model.drop(['Over18'],axis=1, inplace=True)

label_encoder = LabelEncoder()
df_model['Attrition'] = label_encoder.fit_transform(df['Attrition'])
df_model['OverTime'] = label_encoder.fit_transform(df['OverTime'])
df_model['Gender'] = label_encoder.fit_transform(df['Gender'])

df_model = pd.get_dummies(df_model, columns=['BusinessTravel', 'Department', 'EducationField', 'JobRole', 'MaritalStatus'])

df_model

"""## 4.3 Устранение признаков, не имеющих взаимосвязи с данной проблемой

Логически осмыслив, можно удалить наиболее очевидные признаки, которые не нужны для построение модели логистической регрессии - "Over18" и "StandardHours".

В пункте выше столбец с признаком "Over18" уже был удален, так как содержит только оно уникальное значение, что логично, так как IBM ялвяется американской компанией (в США разрешенным возрастом для начала трудовой деятельности является 18 лет).

Кроме того, признак "StandardHours" также не имеет смысла для проблемы, так как этот столбец содержит одинаковое значение для всех сотрудников (стандартные рабочие часы).
"""

df_model['StandardHours'].unique()

df_model.drop(['StandardHours'],axis=1,inplace=True)

"""Для нахождения попарной корреляции всех столбцов в наборе данных используем функцию corr(), которая похожа на матрицу корреляции.

Диапазон изменения коэффициента корреляции от -1 до 1. Чем ближе к 1, тем сильнее положительная корреляция; чем ближе коэффициент к -1, тем сильнее отрицательная корреляция; чем ближе коэффициент к 0, тем больше вероятность, что нет линейной корреляции между двумя атрибутами.
"""

df_correlations=df_model.corr()
df_correlations['Attrition'].sort_values()

sns.set(rc={"axes.facecolor":"white","figure.facecolor":"white"})
plt.figure(figsize=(15,8))
df_correlations['Attrition'].sort_values(ascending = False).plot(kind='bar')

"""Видим, что признак "EmployeeCount" абсолютно не связан с признаком "Attrition", поэтому можем удалить его из нашего датафрейма.

Также можно заметить, что значения коэффициента корреляции между признаками "PercentSalaryHike", "EmployeeNumber", "HourlyRate"                "JobRole_Research Scientist", "PerformanceRating"  и признаком "Attrition" также находятся около нуля, что может означать, что нет линейной корреляции между этими атрибутами. Таким образом, данные столбцы можно удалить из набора данных.


"""

df_model.drop(['EmployeeCount','PercentSalaryHike', 'EmployeeNumber', 'HourlyRate', 'JobRole_Research Scientist', 'PerformanceRating'],axis=1,inplace=True)
df_model.head()

"""В пункте 2.3 мы определили, что в столбцах нет отсутствующих значений, поэтому можем переходить к следующему шагу, а именно

## 4.4 Использование логистической регрессии для бинарной классификации

Цель бинарной классификации в данном случае состоит в том, чтобы предсказать вероятность принадлежности сотрудников к одному из двух классов (0 или 1) зависимой переменной "Attrition" на основе остальных независимых переменных (признаков).

Часто нам нужно все указанные шаги по подготовке признаков делать не один раз, а несколько - для предсказания каждого нового значения. Тогда их логично объединить в Pipeline преобразования и применять как единую операцию.

Шаги по построению модели машинного обучения будут последовательно выполняться в объекте Pipeline. Pipeline экономит время и оптимизирует обучение модели.

Для оценки качества модели мы будем использовать метрику *accuracy*, которая показывает отношение правильных прогнозов к их общему количеству.

Сначала создаем набор входных атрибутов и набор целевых переменных из исходного набора данных.
"""

X=np.array(df_model.drop(['Attrition'],axis=1))
y=np.array(df_model['Attrition'])

"""Разделим данные на данные для обучения и проверки."""

X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=0, test_size=0.2)
print(X_train.shape)
print(X_test.shape)

y_test

pipe = Pipeline([
    ('scaler', StandardScaler()),
    ('classifier', LogisticRegression(solver="liblinear",penalty="l2",
                                      class_weight={0:1,1:1},max_iter=10000))
])

pipe.fit(X_train, y_train)
pipe.named_steps['classifier'].get_params()

"""Построение пайплайна выполняет следующие шаги:

* Сначала создаем компонент "scaler", который выполняет нормализацию данных. Этот компонент использует класс StandardScaler(), предоставленный sklearn, чтобы нормализовать значения каждого столбца в X в соответствии с методом Standardization.

* Следующий шаг - создать метрику "classifier" для выполнения классификации входных выборок по одному из двух классов задачи бинарной классификации. Эта метрика применяет алгоритм логистической регрессии.
"""

predictions_train=pipe.predict(X_train)
predictions_train

predictions_test=pipe.predict(X_test)
predictions_test

accuracy_train = sklearn.metrics.accuracy_score(predictions_train, y_train)
print(accuracy_train)

accuracy_test = sklearn.metrics.accuracy_score(predictions_test, y_test)
print(accuracy_test)

"""Коэффициент accuracy на тренировочных данных составляет 0.89, а на тестовых - 0.88, что означает, что точность модели на представленных выше данных составляет 89% и 88% соответственно. Данный коэффициент является довольно высоким, учитывая ограниченность вводных данных.

1. В результате проведенного анализа данных было выяснено, что представленный датасет является довольно качественным: в нем отсутствуют пропуски и дубликаты, аномалии же, напротив, отсутствуют.

2. Благодаря анализу основных тенденций можно дать следующие рекомендации стейкхолдерам:

* поощрять участие начинающих специалистов и специалистов среднего уровня в различных тренингах, проводимых компанией, горизонтальный рост внутри компании;
* создать прозрачную систему премирования для поощрения сотрудников за проделанную работу и стимулирования к дальнейшей деятельности;
* обеспечить равномерную нагрузку сотрудников касательно деловых поездок;
организация тимбилдингов для поднятия командного духа;
* разобраться, в чем причина увольнения сотрудников, занимающих те или иные должности, исключить возможность неполного штата и неравномерной нагрузки на сотрудников;
* организовать зоны отдыха сотрудников, предоставить возможность проведения сессий с корпоративным психологом и предоставления различных корпоративных скидок.

3. Проведенный анализ тенденций содержит большое количество визуализаций для удобного и информативного представления результатов исследования бизнес-заказчику.

4. На этапе построения модели машинного обучения было достигнуто следующее: :

* была проведена предварительная обработка данных, категориальные признаки были приведены к числовой классификации;
* были удалены признаки, которые не являются статистически значимыми;
* для бинарной классификации (для предсказания принадлежности одному из двух классов (0 или 1) зависимой переменной "Attrition") была использована логистическая регрессия;
* коэффициент accuracy на тренировочных и тестовых данных составляет 0.88 и 0.89 соответственно, что говорит об успешности данной модели.
"""